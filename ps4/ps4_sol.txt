################### Question 1 ###################
1. a. 
	For a given undirected graph G = {V,E} with degree k, we show a polynomial time algorithm to color the graph with k+1 colors.
		-Start with any node in the graph. We choose here to start with the node with the highest degree.
		-Add this node to a coloring queue (a queue of nodes to be colored)
		-while the queue is not empty,
			-grab the node at the front of the queue
			-grab all connected neighbors of the node
			-record all neighbor colors
			-color the current node any color from our k+1 color set that is not a member of the neighbor colors set (which is at most k).
			-any of the neighbors that do not have a color, add to the queue

   b.
	We give an efficient algorithm to color a 3-colorable graph with O(sqrt(n)) colors. Observing two cases: (1) a node has degree < sqrt(n); (2) a node has degree >= sqrt(n). We start by addressing the second case. We first select a node that has the highest degree (>= sqrt(n)). If there are no such nodes, simply use the algorithm from part a. Since the graph is 3-colorable, any subgraph must also be 3-colorable. So we know that we can color the





################### Question 2 ###################	





################### Question 3 ###################
NOTE: -x is the representation in plain-text for the negation of literal, x.
a.
	We would replace the logical expression [-x_i] with (1 + x_i). If our literals take on the values 0 for a literal being True and 1 for a literal being False, if we have a literal that is True, to represent the negatin of that literal in a modulo 2 system, adding 1 to the literal would result in the negation. To replace the logical expression [x_i v x_j], we can use the formula (x_i + x_j - x_i*x_j). To show that this is an equivalent formulation in a modulo 2 system, we can look at the truth tables for two variables. When x_i = 0 and x_j = 0, expression evaluates to 0. When either x_i = 1 or x_j = 1, this expression evaluates to 1. When both x_i = 1 or x_j = 1, this expression also evaluates to 1. Thus, this is an equivalent representation.
	
b.
	If we have expressions for [-x_i] and [x_i v x_j], we can replace all clauses using these two expressions. The order of operations would be as follows:
	1. Replace any negations of any literal, x, with (1+x). Lets call this expression u.
	2. Next, we can split the 3-term clause into two parts:
		-we convert the first two terms, [x v y] using the expression from part a, (x + y - x*y). Lets call this expression w.
		-We are then left with this expression, w, and the third literal. We perform the same substitution, resulting in some expression z for the clause.
	Example:
		Clause: (-x_1 v -x_2 v x_4)
		1. convert negations:
			((1+x_1) v (1+x_2) v x_4)
		2. convert first two literals:
			(((1+x_1)+(1+x_2) - (1+x_1)*(1+x_2)) v x_4)
		3. convert this expression and the final literal:
			for simple notation, we can define u = ((1+x_1)+(1+x_2) - (1+x_1)*(1+x_2)) and compute (u v x_4):
				(u+x_4 - u*x_2)
			written out fully:
				((1+x_1)+(1+x_2) - (1+x_1)*(1+x_2))+x_4 - ((1+x_1)+(1+x_2) - (1+x_1)*(1+x_2))*x_4
	Lets confirm this works with (x_1=1, x_2=1, x_4=1). The original clause will evaluate to True. Our expression will be the following:
		((1+1)+(1+1) - (1+1)*(1+1))+1 - ((1+1)+(1+1) - (1+1)*(1+1))*1 = (4-4)+1 - (4-4)*1 = 1-0 = 1
	If we change x_4=0,
		((1+1)+(1+1) - (1+1)*(1+1))+0 - ((1+1)+(1+1) - (1+1)*(1+1))*0 = (4-4)+0 - (4-4)*0 = 0-0 = 0


c.
	Now that we have a conversion of each clause to an expression, converting the conjunction of these clauses is simple. We simply convert the conjunction of clauses into multiplication. For example, if we have the following formula:
		c_1 ^ c_2 ^ c_3 ^ c_4
	The only time this evaluates to True is when all clauses are True. If a single clause is False, the entire formula evaluates to False. If our clauses are now either 0 or 1, we need to uphold the property that when all clauses are 1, our formula evaluates to 1, but when a single clause is 0, the formula should evaluate to 0. To achieve this, we simply replace all the ^ between clauses with *.
		c_1*c_2*c_3*c_4
	This is an equivalent formulation.
	
d. 
	To solve this system of equations, we can use the Gaussian elimination algorithm. We have a system Ax=b, where A are our clauses, x is a column vector of our literals, and b is a column vector of the clause evaluations (each of which we want to evaluate to 1). Gaussian elimination runs in polynomial time, and the output x are our literal assignments.






















	
	
	
	
	
	
   
   
2. a.


To show that CLSTR is in NP, we need to demonstrate that we can verify a solution to CLSTR in polynomial time.

The problem CLSTR is defined as follows: given an undirected graph G and an integer k, determine whether there exists a clustering of G into k connected components such that the minimum pairwise distance between any two components is at least d.

To verify a solution, we need to check that the proposed clustering is a valid solution. This involves two steps:

1. Verify that the proposed clustering does indeed partition G into k connected components.
2. Verify that the minimum pairwise distance between any two components is at least d.

Both of these steps can be done in polynomial time.

Step 1: To verify that the proposed clustering partitions G into k connected components, we can use a standard algorithm for testing whether a graph is connected. This involves starting from any vertex in each connected component and using breadth-first search or depth-first search to visit all the vertices in that component. If we can find k connected components in this way, then the clustering is valid.

Step 2: To verify that the minimum pairwise distance between any two components is at least d, we can compute the pairwise distances between all pairs of vertices in different components using Dijkstra's algorithm or Floyd-Warshall algorithm. If the minimum distance is at least d, then the clustering is valid.

Since both of these steps can be done in polynomial time, we have shown that CLSTR is in NP.

b. 
   
   We will show that 3COLORING, the problem of deciding whether a given graph can be colored with three colors, is polynomial-time reducible to CLSTR, the problem of clustering a graph into k connected components with minimum pairwise distance at least d. This will imply that CLSTR is at least as hard as 3COLORING, and hence 3COLORING ≤p CLSTR.

The reduction proceeds as follows:

Given an instance G = (V, E) of 3COLORING, we will construct an instance G' = (V', E') of CLSTR as follows:

- Let k = 3 and d = 2 (these values will be used throughout the reduction).
- For each vertex v in V, add a new vertex v' to V'.
- For each edge (u, v) in E, add an edge (u', v') to E'.

Note that the resulting graph G' has 3|V| vertices and |E| edges, and hence can be constructed in polynomial time.

We claim that G can be colored with three colors if and only if G' can be clustered into three connected components with minimum pairwise distance at least 2.

First, suppose that G can be colored with three colors. Let C1, C2, and C3 be the sets of vertices colored with colors 1, 2, and 3, respectively. We will show that G' can be clustered into three connected components with minimum pairwise distance at least 2, as follows:

- The first connected component consists of the vertices in C1 and their corresponding vertices in G'.
- The second connected component consists of the vertices in C2 and their corresponding vertices in G'.
- The third connected component consists of the vertices in C3 and their corresponding vertices in G'.

Note that each connected component contains only vertices of one color, and hence each vertex in a connected component has distance 0 from all other vertices in the same component. Moreover, since G is properly colored, there are no edges between vertices of the same color, and hence there are no edges between vertices in different connected components. Therefore, the minimum pairwise distance between any two connected components is at least 2.

Conversely, suppose that G' can be clustered into three connected components with minimum pairwise distance at least 2. Let C1, C2, and C3 be the sets of vertices in G' corresponding to the vertices in the three connected components. We will show that G can be colored with three colors, as follows:

- Color all vertices in C1 with color 1, and all vertices in C2 with color 2.
- For each vertex v in C3, let N(v) be the set of vertices in C1 and C2 that are adjacent to v in G'. Since the minimum pairwise distance between C1 and C2 is at least 2, we have N(v) ≠ ∅ for all v in C3.
  - If N(v) contains a vertex colored with color 1, color v with color 2.
  - Otherwise, if N(v) contains a vertex colored with color 2, color v with color 1.
  - Otherwise, if N(v) contains only vertices colored with color 3, color v with color 1 or 2 (it doesn't matter which).

Note that this coloring uses only three colors, since any two adjacent vertices in G must belong to different connected components in G'. Moreover, the coloring is proper, since vertices of the same color in G' are not adjacent. Therefore, G can be colored with three colors.

Since the reduction can be done in polynomial time and preserves the answer to the problem, we have shown that 3COLORING ≤p CLSTR.
