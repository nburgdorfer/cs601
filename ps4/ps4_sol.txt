################### Question 1 ###################
1. a. 
	For a given undirected graph G = {V,E} with degree k, we show a polynomial time algorithm to color the graph with k+1 colors.
		-Start with any node in the graph. We choose here to start with the node with the highest degree.
		-Add this node to a coloring queue (a queue of nodes to be colored)
		-while the queue is not empty,
			-grab the node at the front of the queue
			-grab all connected neighbors of the node
			-record all neighbor colors
			-color the current node any color from our k+1 color set that is not a member of the neighbor colors set (which is at most k).
			-any of the neighbors that do not have a color, add to the queue

   b.
	We give an efficient algorithm to color a 3-colorable graph with O(sqrt(n)) colors. Observing two cases: (1) a node has degree < sqrt(n); (2) a node has degree >= sqrt(n). We start by addressing the second case. We first select a node that has the highest degree (>= sqrt(n)). If there are no such nodes, simply use the algorithm from part a. Since the graph is 3-colorable, any subgraph must also be 3-colorable, and any 3 neighbors of a given node cannot be connected in a triangle. Since none of these neighbors an form a triangle, we know that within this neighborhood, each node has at most 3 edges. If we consider this subgraph, N(x) U {x}, we can color this graph using 4 colors using the algorithm in part a. So we color node x with one of the 4 colors, then color each of the neighboring nodes according to the algorithm in part a. We now look for any other nodes with degree >= sqrt(n) and color this node and its neighbors in the same way, but using a different set of 4 colors, as to not have to check invalid colorings between neighborhood clusters. We follow this process until all nodes are colored. If only nodes with degree < sqrt(n) are left uncolored, we can color these nodes and their neighbors with a new set of colors C, where |C| = sqrt(n) following the algorithm in part a. In total, we have at most sqrt(n) nodes with degree >= sqrt(n). Since we use 4 colors for eahc neighborhood, we use 4*sqrt(n) colors. and since we use an additional set of sqrt(n) colors for nodes with degree < sqrt(n), our total number of colors is 5*sqrt(n), which is O(sqrt(n)) colors. Since all ofthe operations are done in polynomial time (using the algorithm from part a.), this algorithm efficiently colors a 3-colorable graph with O(sqrt(n)) colors.





################### Question 2 ###################	
a.
	First, we show that CLSTR is in NP. To prove this, we provide a polynomial time algorithm to verify an instance of CLSTR. We need to verify that the graph is indeed partitioned into k clusters where the distance between each node is bounded by b. If we are given the k clusters, we need to iterate through all node pairs in each cluster and verify that for each pair {i,j}, that D[i,j] <= b. This is polynomial on the order of O(kn^2). Since we can verify this in polynomial time, CLSTR is in NP.
	
b.
	To show that CLSTR is NP-complete, we reduce 3COLORING to CLSTR. To show 3COLORING <=p CLSTR, we start with an instance of 3COLORING.
	
	Suppose we have a graph G = {V,E}. We look to construct a symetric distance matrix from this graph and show that this graph G has a 3COLORING iff D allows a (b,k)-clustering, where we choose b=1 and k=3.
		-For every vertex pair {i,j} in E, we set D[i,j] = 2.
		-For every vertex pair {i,j} not in E, we set D[i,j] = 1.
	From this setting, we obtain a symetric distance matrix D with non-negative entries (the entries along the diagonal are 0).
	
	For the forward direction, we assume that graph G has a 3COLORING. If G has a 3COLORING, we can separate the nodes in G into 3 clusters, X1, X2, X3, where every node in each cluster has the same color. Since this is a proper 3COLORING of the graph, we know that each node pair in each cluster does not have a connecting edge between them. In this case, it is clear that the distance between any two nodes in each cluster is at most b, where b=1. And since we have k=3 clusters, one for each color, D must also allow a (b,k)-clustering.
	
	For the backwards direction, we assume that D allows a (b,k)-clustering, where b=1 and k=3. Since we know that each node pair within each cluster is not connected by an edge, we can simply color every node in each of the 3 clusters with a different color. Thus providing a 3COLORING of the graph G.
	
	Since we constructed our distance matrix D in polynomial time, 3COLORING <=p CLSTR, therefore CLSTR in NP-complete.




################### Question 3 ###################
NOTE: -x is the representation in plain-text for the negation of literal, x.
a.
	We would replace the logical expression [-x_i] with (1 + x_i). If our literals take on the values 0 for a literal being True and 1 for a literal being False, if we have a literal that is True, to represent the negatin of that literal in a modulo 2 system, adding 1 to the literal would result in the negation. To replace the logical expression [x_i v x_j], we can use the formula (x_i + x_j - x_i*x_j). To show that this is an equivalent formulation in a modulo 2 system, we can look at the truth tables for two variables. When x_i = 0 and x_j = 0, expression evaluates to 0. When either x_i = 1 or x_j = 1, this expression evaluates to 1. When both x_i = 1 or x_j = 1, this expression also evaluates to 1. Thus, this is an equivalent representation.
	
b.
	If we have expressions for [-x_i] and [x_i v x_j], we can replace all clauses using these two expressions. The order of operations would be as follows:
	1. Replace any negations of any literal, x, with (1+x). Lets call this expression u.
	2. Next, we can split the 3-term clause into two parts:
		-we convert the first two terms, [x v y] using the expression from part a, (x + y - x*y). Lets call this expression w.
		-We are then left with this expression, w, and the third literal. We perform the same substitution, resulting in some expression z for the clause.
	Example:
		Clause: (-x_1 v -x_2 v x_4)
		1. convert negations:
			((1+x_1) v (1+x_2) v x_4)
		2. convert first two literals:
			(((1+x_1)+(1+x_2) - (1+x_1)*(1+x_2)) v x_4)
		3. convert this expression and the final literal:
			for simple notation, we can define u = ((1+x_1)+(1+x_2) - (1+x_1)*(1+x_2)) and compute (u v x_4):
				(u+x_4 - u*x_2)
			written out fully:
				((1+x_1)+(1+x_2) - (1+x_1)*(1+x_2))+x_4 - ((1+x_1)+(1+x_2) - (1+x_1)*(1+x_2))*x_4
	Lets confirm this works with (x_1=1, x_2=1, x_4=1). The original clause will evaluate to True. Our expression will be the following:
		((1+1)+(1+1) - (1+1)*(1+1))+1 - ((1+1)+(1+1) - (1+1)*(1+1))*1 = (4-4)+1 - (4-4)*1 = 1-0 = 1
	If we change x_4=0,
		((1+1)+(1+1) - (1+1)*(1+1))+0 - ((1+1)+(1+1) - (1+1)*(1+1))*0 = (4-4)+0 - (4-4)*0 = 0-0 = 0


c.
	Now that we have a conversion of each clause to an expression, converting the conjunction of these clauses is simple. We simply convert the conjunction of clauses into multiplication. For example, if we have the following formula:
		c_1 ^ c_2 ^ c_3 ^ c_4
	The only time this evaluates to True is when all clauses are True. If a single clause is False, the entire formula evaluates to False. If our clauses are now either 0 or 1, we need to uphold the property that when all clauses are 1, our formula evaluates to 1, but when a single clause is 0, the formula should evaluate to 0. To achieve this, we simply replace all the ^ between clauses with *.
		c_1*c_2*c_3*c_4
	This is an equivalent formulation.
	
d. 
	To solve this system of equations, we can use the Gaussian elimination algorithm. We have a system Ax=b, where A are our clauses, x is a column vector of our literals, and b is a column vector of the clause evaluations (each of which we want to evaluate to 1). Gaussian elimination runs in polynomial time, and the output x are our literal assignments.
